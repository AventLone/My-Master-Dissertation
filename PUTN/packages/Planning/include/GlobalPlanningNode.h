#pragma once
#include "api/backward.hpp"
#include "api/GlobalPlanner.h"
#include "api/putnDataType.h"
#include <Eigen/Dense>
#include <tf2_ros/transform_listener.h>
#include <visualization_msgs/msg/marker.hpp>
#include <nav_msgs/msg/path.hpp>
#include <std_msgs/msg/float32_multi_array.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>

class GlobalPlanningNode : public rclcpp::Node
{
public:
    explicit GlobalPlanningNode(const std::string& name);

private:
    rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr mMapSub;
    rclcpp::Subscription<nav_msgs::msg::Path>::SharedPtr mWayPointSub;
    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr mGridMapVisualizePub;
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr mPathVisualizePub;
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr mGoalVisualizePub;
    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr mPlaneVisualizePub;
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr mTreeVisualizePub;
    rclcpp::Publisher<std_msgs::msg::Float32MultiArray>::SharedPtr mPathInterpolationVisualizePub;
    rclcpp::Publisher<std_msgs::msg::Float32MultiArray>::SharedPtr mTreeTraVisualizePub;

    bool mHasGoal{false};   // indicate whether the robot has a moving goal

    // simulation param from launch file
    double mResolution, goal_thre, step_size;
    double h_surf_car;
    double mMaxInitialTime;
    double mRadiusFitPlane, mNeighborRadius;
    putn::FitPlaneArg mFitPlaneArg;

    // useful global variables
    Eigen::Vector3d start_pt;
    Eigen::Vector3d target_pt;
    // putn::World* world = NULL;
    std::shared_ptr<putn::World> mWorld{nullptr};
    // putn::planner::PFRRTStar* pf_rrt_star = NULL;
    std::unique_ptr<putn::planner::PFRRTStar> mPFRRTStar{nullptr};

    void waypointsCallback(const nav_msgs::msg::Path::ConstSharedPtr& wp);
    void cloudMapCallback(const sensor_msgs::msg::PointCloud2::ConstSharedPtr& msg);
    void pubInterpolatedPath(const std::vector<putn::Node::Ptr>& solution);
    void findSolution();
    void callPlanner();

    /*** Visualization ***/
    /**
     * @brief visualize the grid map
     */
    // void visualizeWorld(const std::shared_ptr<putn::World>& world);
    void visualizeWorld();

    /**
     * @brief visualize the plane of the nodes along the path generated by PF-RRT*
     */
    void visualizePlane(const std::vector<putn::Node::Ptr>& solution);

    /**
     * @brief visualize the start point and the end point of PF-RRT*
     */
    void visualizeOriginAndGoal(const std::vector<putn::Node::Ptr>& pts);

    /**
     * @brief visualize the path generated by PF-RRT*
     */
    void visualizePath(const std::vector<putn::Node::Ptr>& solution);

    /**
     * @brief visualize the tree of PF-RRT*
     */
    void visualizeTree(const std::vector<putn::Node::Ptr>& tree);
};