#pragma once
#include "api/GlobalPlanner.h"
#include <Eigen/Dense>
#include <std_msgs/msg/float32_multi_array.hpp>
#include <visualization_msgs/msg/marker.hpp>
#include <nav_msgs/msg/path.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <octomap_msgs/msg/octomap.hpp>
#include <tf2_ros/buffer.h>
#include <tf2_ros/transform_listener.h>

class GlobalPlanningNode : public rclcpp::Node
{
    friend putn::planner::PFRRTStar;

public:
    explicit GlobalPlanningNode(const std::string& name);

private:
    bool mHasGoal{false};   // Indicate whether the robot has a moving goal

    double mMaxInitTime;
    double mGoalThreshold;

    /* useful global variables */
    Eigen::Vector3d mStartPoint;   // The real-time robot state()
    Eigen::Vector3d mTargetPoint;
    // const Eigen::Vector3d mTargetPoint{4.3, 0.0, 0.1};

    std::shared_ptr<putn::World> mWorld{nullptr};
    std::unique_ptr<putn::planner::PFRRTStar> mPFRRTStar{nullptr};

    /* TF */
    std::unique_ptr<tf2_ros::Buffer> mTfBuffer{nullptr};
    std::shared_ptr<tf2_ros::TransformListener> mTfListener{nullptr};

    rclcpp::TimerBase::SharedPtr mTimer;

    /* Subscriptions */
    rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr mMapSub;      // Subscrib the map passed from SLAM.
    rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr mGoalSub;   // Subscrib the goal passed from RVIZ.
    // rclcpp::Subscription<nav_msgs::msg::Path>::SharedPtr mGoalSub;            // Subscrib the goal passed from RVIZ.

    /* Publishers */
    rclcpp::Publisher<octomap_msgs::msg::Octomap>::SharedPtr mGridMapVisualizePub;
    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr mPlaneVisualizePub;
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr mPathVisualizePub, mGoalVisualizePub,
        mTreeVisualizePub;
    rclcpp::Publisher<std_msgs::msg::Float32MultiArray>::SharedPtr mGlobalPathPub, mTreeTraPub;

    void callPlanner();

    void visualizeWorld();   // Visualize the grid map.

    /** @brief Visualize the plane of the nodes along the path generated by PF-RRT*. */
    void visualizePlane(const std::vector<putn::Node::Ptr>& solution);

    /** @brief Visualize the start point and the end point of PF-RRT*. */
    void visualizeOriginAndGoal(const std::vector<putn::Node::Ptr>& pts);

    /** @brief Visualize the path generated by PF-RRT*. */
    void visualizePath(const std::vector<putn::Node::Ptr>& solution);

    /** @brief Visualize the tree of PF-RRT*. */
    void visualizeTree(const std::vector<putn::Node::Ptr>& tree);

    void pubGlobalPath(const std::vector<putn::Node::Ptr>& solution);
    void findSolution();

    /* ROS2 Callback functions */
    // void goalCallback(const nav_msgs::msg::Path::ConstSharedPtr& msg);
    void goalCallback(const geometry_msgs::msg::PoseStamped::ConstSharedPtr& msg);
    void cloudMapCallback(const sensor_msgs::msg::PointCloud2::ConstSharedPtr& msg);
};