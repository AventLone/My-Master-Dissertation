#pragma once
#include "api/backward.hpp"
#include "api/GlobalPlanner.h"
#include <Eigen/Dense>
#include <std_msgs/msg/float32_multi_array.hpp>
#include <visualization_msgs/msg/marker.hpp>
#include <nav_msgs/msg/path.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <tf2_ros/buffer.h>
#include <tf2_ros/transform_listener.h>

class GlobalPlanningNode : public rclcpp::Node
{
public:
    explicit GlobalPlanningNode(const std::string& name);

    void callPlanner();

    void setStartPoint(const geometry_msgs::msg::TransformStamped& transform_stamped)
    {
        mStartPoint << transform_stamped.transform.translation.x, transform_stamped.transform.translation.y,
            transform_stamped.transform.translation.z;
    }

    void visualizeWorld();   // Visualize the grid map.

    /** @brief Visualize the plane of the nodes along the path generated by PF-RRT*. */
    void visualizePlane(const std::vector<putn::Node::Ptr>& solution);

    /** @brief Visualize the start point and the end point of PF-RRT*. */
    void visualizeOriginAndGoal(const std::vector<putn::Node::Ptr>& pts);

    /** @brief Visualize the path generated by PF-RRT*. */
    void visualizePath(const std::vector<putn::Node::Ptr>& solution);

    /** @brief Visualize the tree of PF-RRT*. */
    void visualizeTree(const std::vector<putn::Node::Ptr>& tree);

    /* Publishers */
    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr mGridMapVisualizePub, mPlaneVisualizePub;
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr mPathVisualizePub, mGoalVisualizePub,
        mTreeVisualizePub;
    rclcpp::Publisher<std_msgs::msg::Float32MultiArray>::SharedPtr mGlobalPathPub, mTreeTraPub;

    std::unique_ptr<tf2_ros::Buffer> mTfBuffer{nullptr};

private:
    bool mHasGoal{false};   // Indicate whether the robot has a moving goal

    double mMaxInitTime;
    double mGoalThre;

    /* useful global variables */
    Eigen::Vector3d mStartPoint;
    Eigen::Vector3d mTargetPoint;

    std::shared_ptr<putn::World> mWorld{nullptr};
    std::unique_ptr<putn::planner::PFRRTStar> mPFRRTStar{nullptr};

    /* Subscriptions */
    rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr mMapSub;
    rclcpp::Subscription<nav_msgs::msg::Path>::SharedPtr mWayPointSub;


    // tf2_ros::TransformListener mTfListener;
    // std::unique_ptr<tf2_ros::TransformListener> mTfListener;
    // tf2::BufferCore mTfBuffer;
    // tf2_ros::TransformListener mTfListener{mTfBuffer};


    std::shared_ptr<tf2_ros::TransformListener> mTfListener{nullptr};

    void pubGlobalPath(const std::vector<putn::Node::Ptr>& solution);
    void findSolution();

    /* ROS2 Callback functions */
    void waypointsCallback(const nav_msgs::msg::Path::ConstSharedPtr& wp);
    void cloudMapCallback(const sensor_msgs::msg::PointCloud2::ConstSharedPtr& msg);
};